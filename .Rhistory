filename = "figures/dbscan_circle.png"
)
setwd("D:/UCSB/Class/F25/PSTAT231/Final Project")
run_dbscan_and_plot <- function(data, eps, minPts, title, filename) {
db <- dbscan(data, eps = eps, minPts = minPts)
data$cluster <- as.factor(db$cluster)
p <- ggplot(data, aes(x, y, color = cluster)) +
geom_point(size = 1.2, alpha = 0.8) +
theme_minimal() +
ggtitle(title)
ggsave(filename, p, width = 5, height = 4)
print(p)
}
run_dbscan_and_plot(
circle_data,
eps = 0.15,
minPts = 5,
title = "DBSCAN on Circle Dataset",
filename = "figures/dbscan_circle.png"
)
library(dbscan)
library(ggplot2)
library(factoextra)
set.seed(1)
circle <- fviz_cluster(list(data = multishapes[, 1:2], cluster = multishapes$shape),
geom = "point")$data
circle_data <- circle[circle$cluster == 1, 1:2]
names(circle_data) <- c("x", "y")
set.seed(2)
moons <- fviz_cluster(list(data = multishapes[, 1:2], cluster = multishapes$shape),
geom = "point")$data
moons_data <- moons[moons$cluster == 2, 1:2]
names(moons_data) <- c("x", "y")
set.seed(3)
n <- 500
theta <- runif(n, 0, 4*pi)
r <- theta + rnorm(n, 0, 0.3)
x <- r * cos(theta)
y <- r * sin(theta)
spiral_data <- data.frame(x = x, y = y)
data <- as.matrix(data)
library(dbscan)
library(ggplot2)
library(factoextra)
###---------------------------------------------------
### 1. CREATE SYNTHETIC DATASETS
###---------------------------------------------------
# Use multishapes dataset (built into factoextra)
data(multishapes)
# Circle dataset
circle_df <- multishapes[multishapes$shape == 1, 1:2]
colnames(circle_df) <- c("x", "y")
# Two moons dataset
moons_df <- multishapes[multishapes$shape == 2, 1:2]
colnames(moons_df) <- c("x", "y")
# Spiral dataset
set.seed(3)
n <- 500
theta <- runif(n, 0, 4*pi)
r <- theta + rnorm(n, 0, 0.3)
spiral_df <- data.frame(
x = r * cos(theta),
y = r * sin(theta)
)
###---------------------------------------------------
### 2. GENERAL DBSCAN FUNCTION
###---------------------------------------------------
run_dbscan_and_plot <- function(df, eps, minPts, title, filename) {
# Convert to matrix
df_mat <- as.matrix(df)
# Run DBSCAN
db <- dbscan(df_mat, eps = eps, minPts = minPts)
# Add cluster labels
df$cluster <- as.factor(db$cluster)
# Plot
p <- ggplot(df, aes(x, y, color = cluster)) +
geom_point(size = 1.4, alpha = 0.9) +
theme_minimal() +
ggtitle(title)
# Save
ggsave(filename, p, width = 5, height = 4)
print(p)
}
###---------------------------------------------------
### 3. RUN DBSCAN ON EACH SYNTHETIC DATASET
###---------------------------------------------------
run_dbscan_and_plot(
circle_df,
eps = 0.15,
minPts = 5,
title = "DBSCAN on Circle Dataset",
filename = "figures/dbscan_circle.png"
)
run_dbscan_and_plot(
moons_df,
eps = 0.20,
minPts = 5,
title = "DBSCAN on Two Moons Dataset",
filename = "figures/dbscan_moons.png"
)
run_dbscan_and_plot(
spiral_df,
eps = 0.30,
minPts = 5,
title = "DBSCAN on Spiral Dataset",
filename = "figures/dbscan_spiral.png"
)
library(dbscan)
library(ggplot2)
###---------------------------------------------------
### 1. FUNCTIONS FOR SYNTHETIC DATA GENERATION
###---------------------------------------------------
# Circle cluster generator
generate_circle_cluster <- function(center, r, n) {
theta <- runif(n, 0, 2*pi)
data.frame(
x = center[1] + r * cos(theta) + rnorm(n, 0, 0.03),
y = center[2] + r * sin(theta) + rnorm(n, 0, 0.03)
)
}
# Snake / curved cluster generator
generate_snake <- function(start_x, start_y, length, amplitude, noise, n) {
t <- seq(0, length, length/n)
data.frame(
x = start_x + t,
y = start_y + amplitude * sin(t*2) + rnorm(n, 0, noise)
)
}
# Star-shaped cluster
star_cluster <- function(cx, cy, n){
theta <- runif(n, 0, 2*pi)
r <- sample(c(0.2, 0.5, 0.8), n, replace=TRUE)
data.frame(
x = cx + r * cos(theta) + rnorm(n,0,0.02),
y = cy + r * sin(theta) + rnorm(n,0,0.02)
)
}
###---------------------------------------------------
### 2. CREATE SYNTHETIC DATASETS (DATABASE 1 / 2 / 3)
###---------------------------------------------------
## --- Database 1: Large circle + small circles (paper Figure 5 left) ---
set.seed(1)
db1 <- rbind(
generate_circle_cluster(c(0, 0), 1.2, 220),      # big center circle
generate_circle_cluster(c(1.8, 1.4), 0.45, 80),  # small circles
generate_circle_cluster(c(1.6, -1.6), 0.45, 80),
generate_circle_cluster(c(-1.8, -1.3), 0.45, 80),
generate_circle_cluster(c(-2, 1.5), 0.45, 80)
)
## --- Database 2: Snake curves + round clusters (paper Figure 5 middle) ---
set.seed(2)
db2 <- rbind(
generate_snake(0, 0, 8, 1.2, 0.05, 200),
generate_snake(0, -1.3, 8, 1.2, 0.05, 200),
generate_snake(0, +1.3, 8, 1.2, 0.05, 200),
generate_circle_cluster(c(6, 2.5), 0.5, 80),
generate_circle_cluster(c(6, -2.5), 0.5, 80)
)
## --- Database 3: Star shape + small circles + random noise (paper Figure 5 right) ---
set.seed(3)
db3 <- rbind(
star_cluster(-1.2, -0.8, 120),
generate_circle_cluster(c(0, 0), 0.35, 60),
generate_circle_cluster(c(1.5, 1), 0.55, 80),
data.frame(
x = runif(60, -2.5, 2.5),
y = runif(60, -2.5, 2.5)
)
)
###---------------------------------------------------
### 3. GENERAL DBSCAN PLOTTING FUNCTION
###---------------------------------------------------
run_dbscan_and_plot <- function(df, eps, minPts, title, filename) {
db <- dbscan(as.matrix(df), eps = eps, minPts = minPts)
df$cluster <- as.factor(db$cluster)
p <- ggplot(df, aes(x, y, color = cluster)) +
geom_point(size = 1.4, alpha = 0.9) +
theme_minimal() +
coord_equal() +
ggtitle(title)
ggsave(filename, p, width = 5, height = 4)
print(p)
}
###---------------------------------------------------
### 4. RUN DBSCAN ON EACH SYNTHETIC DATASET
###---------------------------------------------------
run_dbscan_and_plot(
db1,
eps = 0.20,
minPts = 8,
title = "DBSCAN on Synthetic Database 1",
filename = "figures/dbscan_db1.png"
)
run_dbscan_and_plot(
db2,
eps = 0.25,
minPts = 8,
title = "DBSCAN on Synthetic Database 2",
filename = "figures/dbscan_db2.png"
)
run_dbscan_and_plot(
db3,
eps = 0.22,
minPts = 8,
title = "DBSCAN on Synthetic Database 3",
filename = "figures/dbscan_db3.png"
)
library(knitr)
# set global chunk options: images will be 7x5 inches
knitr::opts_chunk$set(fig.width=7, fig.height=5)
options(digits = 4)
## indents are for indenting r code as formatted text
## They may need to be adjusted depending on your OS
# if your output looks odd, increase or decrease indent
indent1 = '    '
indent2 = '        '
indent3 = '            '
knitr::include_graphics("figures/dbscan_db1.png")
# Assuming your data is in a data frame called `df`
library(dplyr)
library(dbscan)
library(ggplot2)
library(scales)
# Select and scale longitude & latitude
coords <- df %>%
select(longitude, latitude) %>%
scale()
eps_value <- 0.3
minPts_value <- 10
cat("Running DBSCAN with eps =", eps_value,
"and minPts =", minPts_value, "\n")
db <- dbscan(X, eps = eps_value, minPts = minPts_value)
df <- read.csv("../data/usgs_data.csv")
df_clean <- df %>%
select(longitude, latitude, depth, mag) %>%
na.omit()
cat("Loaded", nrow(df_clean), "earthquake records.\n")
# Standardization
X <- scale(df_clean[, c("longitude", "latitude", "depth", "mag")])
kNNdistplot(X, k = 4)
abline(h = 0.25, col = "darkred", lty = 2)
eps_value <- 0.3
minPts_value <- 10
cat("Running DBSCAN with eps =", eps_value,
"and minPts =", minPts_value, "\n")
db <- dbscan(X, eps = eps_value, minPts = minPts_value)
df_clean$cluster <- as.factor(db$cluster)
cat("DBSCAN produced", length(unique(db$cluster)), "clusters.\n")
ggplot(df_clean, aes(x = longitude, y = latitude, color = cluster)) +
geom_point(alpha = 0.7, size = 1.2) +
scale_color_discrete(name = "Cluster") +
theme_minimal() +
ggtitle(paste("DBSCAN Earthquake Clustering (eps =", eps_value, ", minPts =", minPts_value, ")"))
cluster_summary <- df_clean %>%
group_by(cluster) %>%
summarise(
count = n(),
mean_mag = mean(mag),
median_mag = median(mag),
mean_depth = mean(depth),
median_depth = median(depth),
lon_range = max(longitude) - min(longitude),
lat_range = max(latitude) - min(latitude)
)
cluster_summary
p1 <- ggplot(df_clean, aes(cluster, mag, fill = cluster)) +
geom_boxplot() +
scale_fill_viridis_d() +
ggtitle("Magnitude Distribution by Cluster")
p2 <- ggplot(df_clean, aes(cluster, depth, fill = cluster)) +
geom_boxplot() +
scale_fill_viridis_d() +
ggtitle("Depth Distribution by Cluster")
grid.arrange(p1, p2, ncol = 2)
noise_data <- df_clean %>% filter(cluster == 0)
noise_summary <- noise_data %>%
summarise(
noise_count = n(),
noise_pct = n() / nrow(df_clean) * 100,
mean_mag = mean(mag),
mean_depth = mean(depth)
)
noise_summary
eps_list <- c(0.2, 0.3, 0.5)
sensitivity_results <- map_df(eps_list, function(eps_i) {
db_i <- dbscan(X, eps = eps_i, minPts = 10)
tibble(
eps = eps_i,
clusters = length(unique(db_i$cluster)),
noise_pct = mean(db_i$cluster == 0) * 100
)
})
install.packages("gridExtra")
library(gridExtra)
p1 <- ggplot(df_clean, aes(cluster, mag, fill = cluster)) +
geom_boxplot() +
scale_fill_viridis_d() +
ggtitle("Magnitude Distribution by Cluster")
p2 <- ggplot(df_clean, aes(cluster, depth, fill = cluster)) +
geom_boxplot() +
scale_fill_viridis_d() +
ggtitle("Depth Distribution by Cluster")
grid.arrange(p1, p2, ncol = 2)
library(gridExtra)
p1 <- ggplot(df_clean, aes(cluster, mag, fill = cluster)) +
geom_boxplot() +
scale_fill_viridis_d() +
ggtitle("Magnitude Distribution by Cluster")
p2 <- ggplot(df_clean, aes(cluster, depth, fill = cluster)) +
geom_boxplot() +
scale_fill_viridis_d() +
ggtitle("Depth Distribution by Cluster")
grid.arrange(p1, p2, ncol = 2)
install.packages("purrr")
install.packages("purrr")
library(purrr)
library(tibble)
eps_list <- c(0.2, 0.3, 0.5)
sensitivity_results <- map_df(eps_list, function(eps_i) {
db_i <- dbscan(X, eps = eps_i, minPts = 10)
tibble(
eps = eps_i,
clusters = length(unique(db_i$cluster)),
noise_pct = mean(db_i$cluster == 0) * 100
)
})
sensitivity_results
library(purrr)
library(tibble)
eps_list <- c(0.2, 0.3, 0.5)
sensitivity_results <- map_df(eps_list, function(eps_i) {
db_i <- dbscan(X, eps = eps_i, minPts = 10)
tibble(
eps = eps_i,
clusters = length(unique(db_i$cluster)),
noise_pct = mean(db_i$cluster == 0) * 100
)
})
sensitivity_results
ggplot(sensitivity_results, aes(x = factor(eps), y = clusters)) +
geom_col(fill = "steelblue") +
ggtitle("Number of Clusters at Different eps Values")
ggplot(sensitivity_results, aes(x = factor(eps), y = noise_pct)) +
geom_col(fill = "tomato") +
ggtitle("Noise Percentage at Different eps Values")
ggplot(df_clean, aes(longitude, latitude, color = mag)) +
geom_point(alpha = 0.7) +
scale_color_viridis_c() +
theme_minimal() +
ggtitle("Earthquake Magnitude Distribution")
ggplot(df_clean, aes(longitude, latitude, color = depth)) +
geom_point(alpha = 0.7) +
scale_color_viridis_c() +
theme_minimal() +
ggtitle("Earthquake Depth Distribution")
ggplot(df_clean, aes(longitude, latitude)) +
stat_density_2d(aes(fill = ..level..), geom = "polygon") +
scale_fill_viridis_c() +
theme_minimal() +
ggtitle("Earthquake Spatial Density Map")
ggplot(df_clean, aes(longitude, latitude)) +
stat_density_2d(
aes(fill = after_stat(level)),
geom = "polygon",
contour = TRUE
) +
scale_fill_viridis_c() +
theme_minimal() +
ggtitle("Earthquake Spatial Density Map")
df_clean <- df %>%
select(longitude, latitude, depth, mag) %>%
na.omit()
# Standardization
X <- scale(df_clean[, c("longitude", "latitude", "depth", "mag")])
eps_value <- 0.3
minPts_value <- 10
db <- dbscan(X, eps = eps_value, minPts = minPts_value)
df_clean$cluster <- as.factor(db$cluster)
ggplot(df_clean, aes(x = longitude, y = latitude, color = cluster)) +
geom_point(alpha = 0.7, size = 1.2) +
scale_color_discrete(name = "Cluster") +
theme_minimal() +
ggtitle(paste("DBSCAN Earthquake Clustering (eps =", eps_value, ", minPts =", minPts_value, ")"))
library(gridExtra)
p1 <- ggplot(df_clean, aes(cluster, mag, fill = cluster)) +
geom_boxplot() +
scale_fill_viridis_d() +
ggtitle("Magnitude Distribution by Cluster")
p2 <- ggplot(df_clean, aes(cluster, depth, fill = cluster)) +
geom_boxplot() +
scale_fill_viridis_d() +
ggtitle("Depth Distribution by Cluster")
grid.arrange(p1, p2, ncol = 2)
library(gridExtra)
p1 <- ggplot(df_clean, aes(cluster, mag, fill = cluster)) +
geom_boxplot() +
scale_fill_viridis_d() +
ggtitle("Magnitude Distribution by Cluster")
p2 <- ggplot(df_clean, aes(cluster, depth, fill = cluster)) +
geom_boxplot() +
scale_fill_viridis_d() +
ggtitle("Depth Distribution by Cluster")
grid.arrange(p1, p2, ncol = 2)
par(mfrow = c(1,2))
ggplot(sensitivity_results, aes(x = factor(eps), y = clusters)) +
geom_col(fill = "steelblue") +
ggtitle("Number of Clusters at Different eps Values")
ggplot(sensitivity_results, aes(x = factor(eps), y = noise_pct)) +
geom_col(fill = "tomato") +
ggtitle("Noise Percentage at Different eps Values")
par(mfrow = c(2,1))
ggplot(sensitivity_results, aes(x = factor(eps), y = clusters)) +
geom_col(fill = "steelblue") +
ggtitle("Number of Clusters at Different eps Values")
ggplot(sensitivity_results, aes(x = factor(eps), y = noise_pct)) +
geom_col(fill = "tomato") +
ggtitle("Noise Percentage at Different eps Values")
par(mfrow = c(2,2))
ggplot(sensitivity_results, aes(x = factor(eps), y = clusters)) +
geom_col(fill = "steelblue") +
ggtitle("Number of Clusters at Different eps Values")
ggplot(sensitivity_results, aes(x = factor(eps), y = noise_pct)) +
geom_col(fill = "tomato") +
ggtitle("Noise Percentage at Different eps Values")
par(mfrow = c(1, 2), mar = c(4, 4, 3, 1))
ggplot(sensitivity_results, aes(x = factor(eps), y = clusters)) +
geom_col(fill = "steelblue") +
ggtitle("Number of Clusters at Different eps Values")
ggplot(sensitivity_results, aes(x = factor(eps), y = noise_pct)) +
geom_col(fill = "tomato") +
ggtitle("Noise Percentage at Different eps Values")
par(mfrow = c(2,1), mar = c(4, 4, 3, 1))
ggplot(sensitivity_results, aes(x = factor(eps), y = clusters)) +
geom_col(fill = "steelblue") +
ggtitle("Number of Clusters at Different eps Values")
ggplot(sensitivity_results, aes(x = factor(eps), y = noise_pct)) +
geom_col(fill = "tomato") +
ggtitle("Noise Percentage at Different eps Values")
par(mfrow = c(1, 2), mar = c(4, 4, 3, 1))
# Left plot
print(
ggplot(sensitivity_results, aes(x = factor(eps), y = clusters)) +
geom_col(fill = "steelblue") +
ggtitle("Number of Clusters at Different eps Values") +
theme_minimal()
)
# Right plot
print(
ggplot(sensitivity_results, aes(x = factor(eps), y = noise_pct)) +
geom_col(fill = "tomato") +
ggtitle("Noise Percentage at Different eps Values") +
theme_minimal()
)
par(mfrow = c(2,1), mar = c(4, 4, 3, 1))
# Left plot
print(
ggplot(sensitivity_results, aes(x = factor(eps), y = clusters)) +
geom_col(fill = "steelblue") +
ggtitle("Number of Clusters at Different eps Values") +
theme_minimal()
)
# Right plot
print(
ggplot(sensitivity_results, aes(x = factor(eps), y = noise_pct)) +
geom_col(fill = "tomato") +
ggtitle("Noise Percentage at Different eps Values") +
theme_minimal()
)
par(mfrow = c(1, 2), mar = c(4, 4, 3, 1))
ggplot(sensitivity_results, aes(x = factor(eps), y = clusters)) +
geom_col(fill = "steelblue") +
ggtitle("Number of Clusters at Different eps Values")
ggplot(sensitivity_results, aes(x = factor(eps), y = noise_pct)) +
geom_col(fill = "tomato") +
ggtitle("Noise Percentage at Different eps Values")
p3 <- ggplot(sensitivity_results, aes(x = factor(eps), y = clusters)) +
geom_col(fill = "steelblue") +
ggtitle("Number of Clusters at Different eps Values")
p4 <- ggplot(sensitivity_results, aes(x = factor(eps), y = noise_pct)) +
geom_col(fill = "tomato") +
ggtitle("Noise Percentage at Different eps Values")
grid.arrange(p3, p4, nrow = 1)
df <- read.csv("../data/usgs_data.csv")
df <- read.csv("../data/usgs_data.csv")
head(df)
df_clean <- df %>%
select(longitude, latitude, depth, mag) %>%
na.omit()
# Standardization
X <- scale(df_clean[, c("longitude", "latitude", "depth", "mag")])
head(X)
df_clean <- df %>%
select(longitude, latitude, depth, mag) %>%
na.omit()
head(df_clean)
# Standardization
X <- scale(df_clean[, c("longitude", "latitude", "depth", "mag")])
df <- read.csv("../data/usgs_data.csv")
df_clean <- df %>%
select(longitude, latitude, depth, mag) %>%
na.omit()
head(df_clean)
# Standardization
X <- scale(df_clean[, c("longitude", "latitude", "depth", "mag")])
df <- read.csv("../data/usgs_data.csv")
summary(df)
df_clean <- df %>%
select(longitude, latitude, depth, mag) %>%
na.omit()
head(df_clean)
# Standardization
X <- scale(df_clean[, c("longitude", "latitude", "depth", "mag")])
